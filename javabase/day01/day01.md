1. 基本类型


|     类型     | byte | short | int(默认) | long | float | double（默认） | char | boolean |
| :----------: | :--: | ----- | --------- | ---- | ----- | -------------- | ---- | ------- |
| 大小（字节） |  1  | 2     | 4         | 8    | 4     | 8              | 2    | 4       |

2. 引用类型

除了8种基本数据类型，都是引用类型。方法中的变量，如果是基本数据类型，存储在栈内存中；引用类型存储在堆内存中。new关键字，在堆内存中申请开辟一块新的空间地址。

3. 方法参数传递

java按值传递

- 基本数据类型传递: 传递参数所对应的数据值；
- 引用数据类型传递: 传递的是存储的引用地址值，**有一种特殊的情况，字符串String，传递的是字面量值** 👍

3. 可变参数（0个或多个）

- 如果方法中，有可变参数，还有其他参数，可变参数必须是最后出现，并且只能有一个可变参数；
- 可变参数是兼容数组类型参数的，但是数组类型参数不兼容可变参数；
- 方法调用时，能匹配定长的方法时，优先匹配定长方法，不定参数的方法是最后被选择的；
- 可变参数方法和数组方法不能重载，相同方法名，数组参数和可变参数会被认为是一个方法。👍

4. 方法重载

* 方法名必须相同;
* 访问修饰符可以相同，也可以不相同;
* 返回值类型可以相同，也可以不相同;
* 参数列表必须不同(不区分形参名称的)。 👍
* - 参数的类型不同
  - 参数的个数不同
  - 参数的顺序不同(不推荐使用)

5. 面向对象

系统以对象为中心来组织，对象间相互发送消息，相关的属性和行为被统一到对象上。关注的焦点是对象和对象的功能，系统构建更容易，易维护、易扩展、易复用。解决问题的思想更接近人的思维方式，更容易理解。

类是模板，通过模板创建出具体的实例，就是对象。对象就是实际存在的某类事物的个体。类和对象的关系，就是抽象和具体的关系。

- 在一个.java的文件中，可以有多个class，但是只能有一个class是用public修饰。被声明为public的classI 必须和文件名相同；👍
- 方法体中声明的变量；方法参数中的变量；代码块中的变量；都是局部变量，没有默认值；而类的成员变量都是有默认值的。

> 成员变量有默认值，局部变量没有默认值，产生的原因?
>
> JVM 通过ClassLoader类加载器进行类加载，过程涉及到"加载"、"准备”、"解析"和初始化，类的成员变量初始化，是在JVM类加载的阶段完成。
> 成员变量:静态(static)成员变量、非静态成员变量(初始化阶段赋值，根据代码中的赋值情况，如果没有赋值，则使用默认值，有赋值，则使用代码中的赋值。当对象实例化后，成员变量会随着对象分配到java ***堆内存*** 中)。
>
> 局部变量:存储在 ***栈内存*** 中

- 对象的创建

> 程序计数器、Java栈、堆、本地方法栈、方法区
>
> 当我们创建一个对象时，同时操作了栈和堆：
>
> - 在栈内存中保存对象的引用
> - 对象的属性保存中堆内存中
>
> 操作对象都是通过引用完成，一旦引用出栈，没有被引用的对象就变成了垃圾，应该被回收。
>
> 编写类文件的时候，类文件存储在硬盘上，还没有被加载到内存中。在主方法中，创建了这个类的对象，才会被加载到内存中，进行处理。

- 构造方法


## Java 导包方式

在Java中，导入包或者类是通过import语句实现的，这使得你可以在代码中直接使用这些包或类而无需写出它们的全限定名。Java提供了几种不同的导包方式，以下是常用的几种：

1. 单个类导入

这是最基本的导入方式，直接导入某个具体的类。

> import java.util.Date;

2. 按需导入（静态导入）

如果要使用某个类中的静态成员（如常量、静态方法），可以使用静态导入。

> import static java.lang.Math.PI;
> import static java.lang.System.out;

3. 包名下的所有类导入（通配符导入）

使用星号(*)可以导入一个包下的所有公共类。但不包括子包中的类。虽然这种方式书写简洁，但过度使用可能会导致命名冲突，并降低代码的可读性，因此在实际开发中应谨慎使用。

> import java.util.*;

4. 不显式导入（完全限定名）

如果不使用import语句，也可以直接使用类的全限定名，这种方式不需要导入语句。

> java.util.Date now = new java.util.Date();
