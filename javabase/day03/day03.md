> 类加载时初始化的不仅是静态成员变量，还有实例成员变量。但是静态成员变量必须在类加载阶段就完成初始化，而实例成员变量可以在对象创建阶段进行初始化。如果没有赋初值，就给默认值。但是final修饰的字段必须给初值。

1. 继承

继承：泛化(一般化)，实现子类共享父类属性的方法的机制。在已有类的基础上，扩展出新的类，在新的类中加入特殊的属性和方法。软件复用，提高代码开发效率。子类是父类的一种特殊表现形式。

> class 子类 extends 父类{}
>
> java类支持单继承，一个子类，只能有一个直接父类

- 继承的内存结构：
- - 私有属性和方法 private
    - 子类会继承父类的所有属性和方法，是否能访问，是因为访问权限的问题。
    - java官方文档的解释：子类不能继承父类的私有属性和方法，但是如果子类中公有的方法影响到了父类私有，那私有属性是可以被子类使用的。
  - 默认属性和方法 default
    - 是否可以继承父类默认的属性和方法? 可以继承，在同包下可以访问，在不同包下不可以访问。
  - 受保护的属性和方法 protected
    - 可以继承，在同包下可以访问，在不同包下也可以访问。
  - 共有属性和方法 public
    - 可以继承，在同包下可以访问，在不同包下也可以访问。

> 总结: 私有的不可以访问，默认的在同包下可以访问，受保护的和公有的，可以在不同包访问，相当于在子类中声明一样使用。

2. 子类实例化过程

> 子类实例化，需要调用父类的构造方法，无参构造可省略，有参构造不可省略。 👍
>
> 在子类创建对象时，不会创建父类对象。只是创建了父类空间，并进行了初始化。

- 父类构造方法不能被子类继承;
- 在子类的构造方法中，调用了父类的构造方法；
- 如果父类有无参的构造方法，子类super()可以省略；
- 如果父类中没有无参的构造方法，子类super(参数)不可以省略；
- 如果使用super()显式地调用父类的构造方法，要求必须写在子类构造方法中的第一行；👍
- 子类的构造方法中，不能同时出现super()和this()。

> ```java
>  java
> public Car(String color){
>     System.out.println("这是父类有参构造器");
> }
>
> public Aodi() {
>     super("blue"); // 不可省略
>     System.out.println("这是子类构造器");
> }
>
> // 或者
> public Car() {
>     System.out.println("这是父类构造器");
> }
>
> public Aodi() {
>     super(); // 可省略
>     System.out.println("这是子类构造器");
> }
> ```

3. 属性隐藏

- 在父类中定义一个属性，在子类中定义了一个同名的属性，在子类中访问，会隐藏父类的属性，即被覆盖掉；
- 在子类中，有两个同名属性，一个是继承自父类的，使用super.属性名访问，一个是子类自己的，使用this.属性名访问；👍
- 在方法中，如果访问到属性，继承自父类的方法，使用的是父类的属性，子类自己的方法，使用的是子类属性；
- 如果父类中有一个静态变量，则被所有子类所共享，其中一个子类修改了值，其他子类访问也是修改后的值。如果子类自己写了一个同名的静态变量，则子类中访问的是自己的变量，不再是父类变量。

4. 方法重写

方法重写，子类中对父类(祖先类)存在的同名方法，进行改造，去覆盖父类同名方法的机制。方法重写的要求：

(两同两小一大)

- 方法名必须相同； 同
- 参数列表必须相同； 同
- 父类方法不能是私有的；
- 访问修饰符必须 大于等于父类方法的访问修饰符；👍 大
- 返回值类型 小于等于父类方法的返回值类型；👍 小
- 子类抛出异常 小于等于父类抛出的异常；👍 小

使用方法重写的场景:子类和父类的方法要完成相同功能，但采用不同的算法或公式。

5. 抽象

> 完成设计和实现的分离

- 抽象方法：使用abstract关键字修饰，只有方法的声明(方法头)，没有方法的实现(方法体)。且不能是static方法（抽象方法重在抽象，不具体实现某些功能，静态方法是具体的，将抽象方法具体化与设计原则相悖）
- 抽象类: 使用abstract关键字修饰，可以有抽象方法，也可以有普通方法，也可以有构造方法，也可以没有抽象方法。如果一个类中有抽象方法，则这个类必须是抽象类。
- 方法重写的时候，必须要重写的方法是abstract修饰的抽象方法。如果子类不重写父类的抽象方法，则子类必须是抽象类。🚀️
- 抽象类不能被实例化。

6. final

> final修饰的方法和类，不是能是abstract抽象的。因为这两个定义的目的是相反的👍

- final定义常量

  - 修饰引用类型：对象的引用地址不可修改，但可以修改属性值；
  - 修饰基本类型：值不能修改；
  - 编译期常量、非编译期常量：👍
    - 不是所有的final修饰的字段都是编译期常量，非编译期常量，在被初始化之后无法修改；
    - 非编译器常量由于初始化值得不确定而不确定，但是一旦初始化之后就不能修改了；
    - ```java
      public class Point01 {
          public static void main(String[] args) {
              Aodi aodi = new Aodi(); //
              C c1 = new C();
              System.out.println(c1.i);
              System.out.println(c1.j);

              C c2 = new C();
              System.out.println(c2.i);
              System.out.println(c2.j);
          }

      }

      class C {
          public final int i = 0; // 编译期常量
          public final int j = new Random().nextInt(10); // 非编译期常量
      }
      ```
  - static final
    - 一个既是static，又是final的字段，只占据一段不能改变的存储空间。因为是属于类的字段，只需要一段存储空间，但是不能改变。
- final定义终结类

  - 当一个类定义为final时，就表明不能继承这个类，表示不能产生子类。
  - final类里面的所有方法，都是隐式的final,不会产生子类，也不会覆盖方法，所以不需要在final类中为方法加final关键字;
- final定义终结方法

  - 不能被子类重写；
  - 所有private方法都是隐式地final方法，在private方法中，不需要使用final关键字修饰，没有意义；
  - final方法可以被重载；👍
- final 的初始化

  必须进行初始化

  - 类的普通成员变量: 在定义时，可以直接初始化，也可以先不做初始化，在构造方法或构造代码块中，进行初始化;
  - 静态成员变量：要么定义时直接初始化，要么在静态代码块中初始化。(不能使用构造方法，因为构造方法只有在对象创建时才会调用，但是静态成员属于类，应该在类加载时就进行初始化操作，所以不能放在构造方法中初始化)。
  - > ```java
    > //    public final static int y = 10;
    >     public final static int y;
    >
    >     static {
    >         y = 10;
    >     }
    > ```
    >
  - > ```java
    > // public final int x = 10;
    > public final int x;
    > //    {
    > //        x = 100;
    > //    }
    >
    > public C(int x) {
    >     this.x = x;
    > }
    > ```
    >

```java
class A{
    public void fun1(){
    }

    public final void fun2(){}
    public void fun2(int x){} // final方法可以被重载，但不能被子类重写

}
class B extends A {
    @Override
    public void fun1() {
        super.fun1();
    }
    @Override
    public void fun2(int x){ // 如果重载的方法是非final的，则可以被子类重写
    }
}
```

7. 多态

- 向上转型

> 父类的引用指向子类的对象(将子类对象赋值给父类对象)👍
>
>> 父类类型 对象名=new 子类类型();
>>
>
> 编译时，看左边，运行时，看右边。只能调用到父类中声明过的方法，不能调用子类中的特殊方法：
>
> - 方法的运行，看右边；子类的结果
> - 属性的调用，看左边；父类的属性
>
> 将子类声明成父类类型，得到的对象编译时认为是父类的，运行时认为是子类的，属性是父类的，方法是子类的。

- 向下转型

> 子类的引用指向父类的引用👍
>
> 语法: 子类类型 对象名 = (子类类型)父类引用;
>
> 只能强制转换父类的引用，不能强制转换父类的对象(如果强制转换父类对象，编译可以通过，运行时报错)
>
> 转换的前提是父类的引用必须是经过向上转型的对象, 可以调用子类中声明的所有方法

```java
public class Point02_Polymorphism {
    public static void main(String[] args) {
        F f = new S(); // 向上转型
        f.show();
        S s = (S) f; // 向下转型
        s.show1();
        S s1 = (S) new F(); // 只能强制转换父类的引用，不能强制转换父类的对象(如果强制转换父类对象，编译可以通过，运行时报错)
    }
}

class F {
    public void show(){
        System.out.println("这是父类方法show");
    }
}

class S extends F{
    public void show(){
        System.out.println("这是子类方法show");
    }
    public void show1(){
        System.out.println("这是子类方法show1");
    }
}
```

- 多态

> 具有多种表现形态，三个必要条件
>
> - 要有继承
> - 要有重写
> - 父类引用指向子类对象!
>
> 优点:
>
> - 简化代码
> - 面向抽象编程，不面向具体编程。(依赖倒转原则)
> - 易于扩展 增强代码可读性

- 里氏代换原则

父类出现的地方，子类一定可以出现
子类出现的地方，父类不一定可以出现

> 子类可以赋值/传给父类，但是父类不能赋值/传给子类
>
> 父类引用了子类可以强转为子类，否则不可以强转为子类


8. instanceof 运算符

判断一个对象是否属于某个类(或其父类)，返回boolean类型的值，如果属于返回true, 否则false。

```java
        if(s instanceof S) {
            System.out.println("这是S类的()或其父类的对象");
        }
        if(new S() instanceof F) {
            System.out.println("这是S类的()或其父类的对象");
        }
```


9. 静态方法不能被重写 🔴

子类可以写一个和父类相同的静态方法，但当使用多态机制，将子类声明成父类类型时，调用的静态方法，还是父类的静态方法，不能实现方法的覆盖。

> - 必须要重写的方法: abstract修饰的抽象方法 ❤️
> - 不能重写的方法: 构造方法、private、final、static ❤️
